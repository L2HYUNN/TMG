# 06/27 (화)

## 계층형 설계
함수형 프로그래밍 계층형 설계 파트를 읽고 기억에 남는 부분을 정리해보자.

### 직접 구현
적절한 함수 추출을 이용하여 더욱 일반적인 계층의 함수를 만들 수 있고 이것을 `직접 구현`이라고 부른다.

직접 구현을 이용하여 우리는 함수로 이루어진 계층을 만들 수 있다. 계층을 호출 그래프로 표현하면 계층에 대한 많은 정보를 쉽게 파악할 수 있다. 계층의 아래에 있을수록 더욱 일반적인 함수로 구성되어 있다. 

계층형 설계가 필요했던 이유는 무엇일까? 앞에서 배웠던 함수형 프로그래밍 방식을 이용하면 액션, 계산, 데이터를 효과적으로 분류해낼 수 있었다. 이를 통해 우리는 다양한 함수를 만들 수 있다. 가독성을 위해서는 명령형보다 선언형으로 동작을 표현하는 것이 좋다. 하지만 선언형으로 만들게 되면 선언 방식에 따라 다른 추상화 레벨을 가지게 될 수 있다. 추상화 수준이 다른 함수들로 구현되어 있는 함수는 가독성을 떨어트린다. 따라서 하나의 함수에는 동일한 추상화 레벨을 가진 함수들로 표현하는 것이 좋다. 이를 위해서는 추상화 레벨에 따른 계층으로 함수를 구분할 필요가 있다.

### 추상화 벽
직접 구현 패턴을 통해 우리는 추상화 계층을 만들 수 있게 되었다. 고수준의 추상화 계층을 만들게 되면 세부 구현은 숨기고 동작에만 집중 할 수 있게 된다. 이를 통해 우리는 하나의 계층을 인터페이스로 만들 수 있게 된다. 이러한 하나의 인터페이스 계층을 `추상화 벽`이라고 부른다.

추상화 벽 덕분에 사용자는 세부 구현을 모르더라도 함수를 이용할 수 있다. 이를 통해 개발을 할 때 신경써야 하는 부분과 신경을 쓰지 않아도 되는 부분을 구분할 수 있다.

### 작은 인터페이스
우리는 직접 구현 패턴을 통해 추상화 계층을 만들 수 있게 되었고 이를 통해 하나의 인터페이스를 만들 수 있게 되었다.

이론적으로 우리는 무한한 인터페이스를 만들 수 있다. 인터페이스는 사용자와의 하나의 약속이라고 생각할 수 있다. 인터페이스가 많아진다는 것은 약속이 많아진다는 것을 의미하고 이것은 곧 알아야 할 내용이 많아진다는 것을 의미한다. 따라서 인터페이스는 가능한 작게 유지하는 것이 좋다. 두 계층에서 동일한 함수를 만들 수 있다면 가능한 윗 계층에 함수를 만드는 것이 좋다.

아래 계층에 있는 함수가 많아질수록 변경 사항이 있을 때 고쳐야 할 부분이 많아진다. 또한 아래 계층에 있는 함수 일수록 낮은 수준의 코드이기 때문에 더 많은 버그가 발생할 수 있고 가독성이 떨어진다. 따라서 아래 계층에 인터페이스 일수록 가능한 작게 유지하는 것이 옳다.

`작은 인터페이스`의 패턴의 이상적인 모습은 필요한 함수만 가지고 있는 계층들로 이루어져 있으며 모든 계층의 함수는 추가 및 변경이 일어나서는 안된다. 현실적으로 어려운 부분이지만 이상적인 모습을 지향하는 것이 옳다.

### 편리한 계층
계층형 설계에 대해서 배웠지만 실질적으로 모든 부분에 계층을 적용하기는 어렵다. 완벽한 추상화 계층을 만드는 것이 상당히 어렵기 때문이다. 우리는 비지니스 문제를 해결해야하고 문제는 항상 우리를 기다려주지 않는다. 따라서 제한된 시간동안 완벽한 계층을 만들기란 현실적으로 어렵다고 생각할 수 있다. 

그렇기에 우리는 `편리한 계층` 패턴을 이용해야 한다. 현재 작업중인 코드가 이해하기 쉽고 새로운 기능을 추가하는데 어렵지 않다면 굳이 계층형 설계를 적용할 필요는 없다. 하지만 이후에 새로운 기능이 추가되고 수정사항들이 생겨나면서 코드를 관리하기 어려워진다면 다시 위에서 배운 패턴들을 적용하자. 이를 통해 우리는 현실적으로 구현 가능한 계층을 가질 수 있게 될 것이다.

### 호출 그래프
우리는 호출 그래프를 통해 함수의 유지보수성, 테스트 가능성, 재사용성등의 정보를 얻을 수 있다.

#### 유지 보수성
위로 연결된 것이 적은 함수일수록 변경이 쉽다. 위로 연결된 것이 적다는 것은 의존하고 있는 함수가 적다는 의미이기 때문이다. 따라서 가장 유지 보수가 쉬운 함수는 계층 가장 위에 있는 함수이다. 자주 바뀌는 함수일수록 계층 위에 있어야 한다.

#### 테스트 가능성
위로 연결된 것이 많은 함수를 테스트하는 것이 더욱 가치 있다. 위로 연결된 것이 많다는 것은 그만큼 전체 코드에 더 많은 영향을 주고 있다는 뜻이기 때문이다. 따라서 테스트 가치가 높은 함수는 계층 가장 아래에 있는 함수이다. 보통 계층 아래일수록 위로 연결된 것이 많기 때문이다.

#### 재사용성
아래 게층에 있는 함수일수록 재사용성이 높다. 아래 계층은 위의 계층에 비해 더욱 일반적인 함수들로 구성되어있기 때문이다.

## 적용
이번에 이팩티브 기술 면접 피드백 기능을 개발하면서 계층형 설계의 일부를 적용해보았다. 적용하게 된 이유는 편리한 계층 패턴의 이유와 동일하다. 하나의 컴포넌트가 너무 많은 일을 하고 있었기에 가독성이 떨어지고 기능을 추가 및 수정하기 어려워졌다. 또한 피드백 기능이 들어가는 부분은 서비스의 가장 중요한 비지니스 로직이라고 생각할 수 있었고 이 부분은 추후 기획 변경에 따라 언제든지 변경될 수 있는 따라서 가장 위의 계층에 존재하는 함수들이었다. 따라서 지금 당장 리팩토링을 통해 기능 추가 및 변경이 용이한 구조로 변경할 필요가 있다고 생각했다.

피드백 기능이 추가되면서 UI에도 변화가 있었는데 이로 인해 더 많은 이벤트와 로직들이 추가되게 되었다. 이로 인해 하나의 컴포넌트로 분리하더라도 UI위에는 많은 복잡한 로직들이 자리잡게 되었고 이로 인해 컴포넌트의 동작을 쉽게 이해할 수 없게 되었다. 따라서 이 부분에도 새로운 추상화와 그에 따른 계층이 필요하다고 생각했다. 이를 해결하기 위해 가장 쉬운 접근 방법으로 UI와 Application 즉 로직 부분을 변경하는 계층으로 나누었고 Application에서도 이벤트에 따라 함수를 추상화하여 사용할 수 있게 커스텀 hook을 이용하여 리팩토링하였다.

이후에는 hooks에서 추상화 계층을 더욱 상세히 나누는 방식으로 코드를 리팩토링할 수 있을 것 같다.