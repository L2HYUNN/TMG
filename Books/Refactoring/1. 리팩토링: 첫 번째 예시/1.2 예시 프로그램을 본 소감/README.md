# 1.2 예시 프로그램을 본 소감
컴파일러는 코드가 깔끔하든 지저분하든 개의치 않는다.

하지만 그 코드를 수정하려면 사람이 개입되고, 사람은 코드의 미적 상태에 민감하다.

먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성하자. 프로그램의 구조가 빈약하다면 대체로 구조부터바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩토링하고 나서 원하는 기능을 추가한다.

### 예시
예시: 연극을 외주 받아 공연하는 극단

- 공연 요청시 연극의 장르, 관객 규모를 기초로 비용을 책정한다.
- 극단은 두 가지 장르 비극(tragedy), 희극(comedy)만을 공연한다.
- 공연료와 별개로 포인트(volume credit)을 지급한다. (다음번 의뢰 시 공연료를 할인받을 수 있다)

### 청구 내역을 HTML로 출력하는 기능이 필요하다고 생각해보자.
청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야 한다.

결과적으로 `statement()` 함수의 복잡도가 증가한다.

따라서 대부분 이 함수의 복사본을 만들어서 처리하려고 할 것이다.

복사 비용은 그리 부담되지 않지만 청구서 작성 로직을 변경할 때마다 두 함수 모두를 수정하고 일관되게 관리해주어야 하니 문제가 될 가능성이 크다.

### 연극의 장르가 여러개 추가된다고 생각해보자.
비지니스상 충분히 생각할 수 있는 케이스이다.

장르가 추가된다는 것은 곧 공연료와 적립 포인트 계산법에 영향을 준다는 것을 의미한다.

따라서 연극 장르와 공연료 정책이 달라질 때마다 `statement()` 함수를 수정해야 한다.

### 개인적인 생각
현재 예시 함수의 동작을 이해하기 위해서는 모든 코드의 작동 방법을 읽고 이해해야만 한다.

예를 들어 연극 비용을 계산하는 로직의 경우 `for`문과 `switch`문으로 이루어진 모든 로직을 읽어야만 이해할 수 있다.

그렇기에 주석을 이용하여 각 코드를 설명해주는 것이 아니라면 원하는 부분을 찾거나 코드를 이해하는데 많은 시간을 할애해야 할 것이다.

결과적으로 이러한 문제들로 인해 프로그램의 유지보수 비용을 증가시킬 것이다.

### 결론
리팩토링이 필요한 이유는 결국 이러한 변경 때문이다.

다른 사람이 읽고 이해해야 할 일이 생기는 한 로직은 한눈에 쉽게 파악할 수 있어야 한다.