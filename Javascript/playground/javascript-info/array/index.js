/**
 * # 배열
 * 배열은 순서가 있는 컬렉션을 저장할 때 사용할 수 있는 자료구조 입니다.
 *
 * 키를 사용해 식별할 수 있는 값을 담은 객체와 달리 순서가 있는 컬렉션에는
 * 순서 관련 메서드를 제공하는 배열을 사용하는 것이 좋습니다.
 */

/**
 * ## 배열 선언
 * 아래 두 문법을 사용하여 빈 배열을 만들 수 있습니다.
 */

let arr = new Array();
let arr2 = [];

// 대부분 두 번째 방법을 이용하여 배열을 선언합니다.
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소엔 0부터 시작하는 숫자(인덱스)가 존재하며, 이를 통해 배열내 요소에 접근할 수 있습니다.
alert(fruits[0]); // 사과
alert(fruits[1]); // 오렌지
alert(fruits[2]); // 자두

// 요소 수정
fruits[2] = "배"; // 배열이 ["사과", "오렌지", "배"]로 바뀜

// 새로운 요소 추가
fruits[3] = "레몬"; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜

// 배열의 길이
alert(fruits.length); // 3

/**
 * ## pop-push와 shift-unshift
 * 큐(queue)는 배열을 사용해 만들 수 있는 대표적인 자료구조 입니다.
 * 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용할 수 있습니다.
 * 큐에서 사용하는 주요 연산은 아래와 같습니다.
 *
 * - push: 맨 끝에 요소를 추가합니다.
 * - shift: 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어줍니다.
 *
 * 배열은 큐 이외에 스택(stack)을 구현할 떄도 사용됩니다.
 * 스택에서 사용하는 주요 연산은 아래와 같습니다.
 *
 * - push: 요소를 스택 끝에 집어넣습니다.
 * - pop: 스택 끝 요소를 추출합니다.
 */

// pop
// 배열 끝 요소를 제거하고, 제거한 요소를 반환합니다.
alert(fruits.pop()); // 배열에서 "배"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert(fruits); // 사과,오렌지

// push
// 배열 끝에 요소를 추가합니다.
fruits.push("배");

alert(fruits); // 사과,오렌지,배

// shift
// 배열 앞 요소를 제거하고, 제거한 요소를 반환합니다.
alert(fruits.shift()); // 배열에서 "사과"를 제거하고 제거된 요소를 얼럿창에 띄웁니다.

alert(fruits); // 오렌지,배

// unshift
// 배열 앞에 요소를 추가합니다.
fruits.unshift("사과");

alert(fruits); // 사과,오렌지,배

/**
 * ## 배열의 내부 동작 원리
 * 배열은 숫자형 키를 사용하기 때문에 객체 기본 기능 이외에도 순서가 있는 컬렉션을
 * 제어하게 해주는 특별한 메서드를 제공합니다. (배열의 본질은 객체입니다.)
 */

// 배열은 객체와 마찬가지로 참조를 통해 복사됩니다.
let fruits = ["바나나"];

let arr3 = fruits; // 참조를 복사함(두 변수가 같은 객체를 참조)

alert(arr3 === fruits); // true

arr3.push("배"); // 참조를 이용해 배열을 수정합니다.

alert(fruits); // 바나나,배 - 요소가 두 개가 되었습니다.

/**
 * 배열을 배열답게 만들어주는 것은 특수한 내부 표현방식입니다.
 *
 * 자바스크립트 엔진은 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높입니다.
 * 이 방법 이외에도 배열 관련 연산에 대한 최적화 기법은 다양합니다.
 */

// '순서가 있는 자료의 컬렉션'처럼 다루지 않고 일반 객체처럼 다루는 경우 이러한 기법들이 제대로 동작하지 않습니다.

let fruits = []; // 빈 배열을 하나 만듭니다.

fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만듭니다.

fruits.age = 25; // 임의의 이름을 사용해 프로퍼티를 만듭니다.

/**
 * 배열은 객체이므로 예시처럼 원하는 프로퍼티를 추가해도 문제가 발생하지 않습니다.
 *
 * 하지만 이러한 접근은 자바스크립트 엔진이 배열을 일반 객체처럼 다루게 하여 배열을 다룰 때
 * 적용되는 최적화 기법이 동작하지 않도록 합니다.
 *
 * 잘못된 방법의 예는 다음과 같습니다.
 * - arr.test = 5 같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
 * - arr[0]과 arr[1000] 만 추가하고 그 사이에 아무런 요소도 없는 경우
 * - arr[1000], arr[999] 같이 요소를 역순으로 채우는 경우
 */

/**
 * ## 성능
 * push 와 pop은 빠르지만 shift와 unshift는 느립니다.
 *
 * shift, unshift의 경우 배열에 요소를 추가, 제거 해주는 것 뿐아니라
 * 모든 요소를 이동시키고 인덱스를 바꿔줘야 합니다.
 *
 * 배열의 요소가 많으면 요소가 이동하는 데 걸리는 시간이 길고 메모리 관련 연산도 많아집니다.
 *
 * 반면 push, pop의 경우 요소를 옮기지 않으므로 각 요소는 기존 인덱스를 그대로 유지합니다.
 */

/**
 * ## 반복문
 */

// for 문
for (let i = 0; i < arr.length; i++) {
  alert(arr[i]);
}

// for..of 문
// 배열 요소를 대상으로 반복 작업을 수행합니다.
for (let fruit of fruits) {
  alert(fruit);
}

// for..in 문
// 배열은 객체형에 속하기 때문에 for..in 문법을 사용하는 것도 가능합니다.
for (let key in arr) {
  alert(arr[key]); // 사과, 오렌지, 배
}

/**
 * for..in 문은 다음과 같은 특징을 지니기 때문에
 * 배열에 사용시 문제가 발생할 수 있습니다.
 *
 * 1. for..in 반복문은 모든 프로퍼티를 대상으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함됩니다.
 *
 * 2. for..in 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것 대비
 *    10 ~ 100배 정도 느립니다. for..in 반목문의 속도가 대체로 빠른 편이기 때문에 병목 지점에서만 문제가 되지만 이러한 차이를 이해하는 것이 중요합니다.
 *
 * 이러한 이유로 가능하면 배열에는 for..in을 사용하지 않는 것이 좋습니다.
 */

/**
 * ## 'length' 프로퍼티
 * 배열에 무언가 조작을 가하면 length 프로퍼티가 자동으로 갱신됩니다.
 * length 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에서 1을 더한 값입니다.
 */

// 배열에 요소가 하나 있더라도, 아주 큰 인덱스를 가진다면 배열의 length 프로퍼티 또한 아주 커집니다.
let fruits = [];
fruits[123] = "사과";

alert(fruits.length); // 124

// length 프로퍼티는 쓰기가 가능합니다.
// 따라서 아래와 같이 length를 조정하여 배열을 자를 수 있습니다.
let arr4 = [1, 2, 3, 4, 5];

arr4.length = 2; // 요소 2개만 남기고 잘라봅시다.
alert(arr4); // [1, 2]

arr4.length = 5; // 본래 길이로 되돌려 봅시다.
alert(arr4[3]); // undefined: 삭제된 기존 요소들이 복구되지 않습니다.

/**
 * ## new Array()
 */

let arr5 = new Array("사과", "배", "기타");

// 대괄호 문법에 비해 길고 아래와 같은 까다로운 기능이 있기 때문에 잘 사용되지 얂는 편입니다.
// 아래와 같이 숫자형 인수 하나를 넣어서 new Array를 호출하여 만들어진 배열은 요소가 없는 반면 인수와 같은 length를 가지게 됩니다.

let arr6 = new Array(2); // 이렇게 하면 배열 [2]가 만들어질까요?

alert(arr6[0]); // undefined가 출력됩니다. 요소가 하나도 없는 배열이 만들어졌네요.

alert(arr.length); // 길이는 2입니다.

/**
 * ## 다차원 배열
 * 배열 역시 배열의 요소가 될 수 있습니다.
 * 이러한 배열을 가리켜 다차원 배열(multidimensional array)이라 부릅니다.
 *
 * 다차원 배열은 행렬을 저장하는 용도로 쓰입니다.
 */

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];

alert(matrix[1][1]); // 5, 중심에 있는 요소

/**
 * ## toString
 * 배열엔 toString 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환됩니다.
 */

let arr7 = [1, 2, 3];

alert(arr7); // 1,2,3
alert(String(arr7) === "1,2,3"); // true
