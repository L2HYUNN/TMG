/**
 * # 가비지 컬렉션
 * 자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행합니다.
 */

/**
 * ## 가비지 컬렉션 기준
 * 자바스크립트는 도달 가능성(reachability) 이라는 개념을 사용해 메모리 관리를 수행합니다.
 *
 * '도달 가능한(reachable)' 값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미합니다.
 * 도달 가능한 값은 메모리에서 삭제되지 않습니다.
 *
 * 아래 값들은 태생부터 도달 가능하기 때문에, 명백한 이유 없이는 삭제되지 않는다.
 * - 현재 함수의 지역 변수와 매개변수
 * - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
 * - 전역 변수
 * - 기타 등등
 *
 * 이러한 값들을 루트(root)라고 부른다.
 *
 * - 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.
 */

// 자바스크립트 엔진 내에선 가비지 컬렉터(garbage collector)가 끊임없이 동작한다.
// 가비지 컬렉터는 모든 객체를 모니터링하고, 도달할 수 없는 객체는 삭제한다.

/**
 * ## 간단한 예시
 */

// user엔 객체 참조 값이 저장됩니다.
let user = {
  name: "John",
};

// name 프로퍼티에 접근할 방법이 사라졌다.
// 따라서 가비지 컬렉터는 저장된 name을 메모리에서 삭제한다.
user = null;

/**
 * ## 참조 두 개
 */

// user엔 객체 참조 값이 저장됩니다.
let user2 = {
  name: "John",
};

let admin = user2;

// 전역 변수 admin을 통하면 여전히 name을 참조할 수 있기 때문에 메모리에서 삭제되지 않는다.
user = null;

/**
 * ## 연결된 객체
 * // 그림을 포함한 홈페이지에서 이해하는 것이 좋다.
 */

// 만들어진 모든 객체는 도달 가능한 상태이다.
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman,
  };
}

let family = marry(
  {
    name: "John",
  },
  {
    name: "Ann",
  }
);

// 아빠에 대한 참조 두 개를 지운다.
delete family.father;
delete family.mother.husband;

// 삭제한 두 개의 참조 중 하나만 지웠다면, 모든 객체가 여전히 도달 가능한 상태였을 것이다.
// 하지만 참조 두 개를 지우면서 father에 대한 모든 참조가 사라졌기 때문에 도달 가능한 상태에서 벗어났다.

/**
 * ## 도달할 수 없는 섬
 * 객체들이 연결되면서 섬 같은 구조를 만드는데, 이 섬에 도달할 방법이 없는 경우, 섬을 구성하는 객체 전부가 메모리에서 삭제된다.
 */

// 도달할 수 없는 섬 개념의 예시
family = null;

// "family" 객체와 루트의 연결이 사라지면서 루트 객체를 참조하는 것이 아무것도 없게 된다.
// -> 섬 전체가 도달할 수 없는 상태가 되어, 섬을 구성하는 객체 전부가 메모리에서 제거된다.

/**
 * ## 내부 알고리즘
 * 'mark-and-sweep'이라 불리는 가비지 컬렉션 기본 알고리즘에 대해 알아보자.
 * - 가비지 컬렉터는 루트(root) 정보를 수집하고 이를 'mark(기억)' 합니다.
 * - 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 'mark' 합니다.
 * - mark 된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark 합니다.
 *  한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없습니다.
 * - 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복합니다.
 * - mark 되지 않은 모든 객체를 메모리에서 삭제합니다.
 */

/**
 * 가비지 컬렉션 최적화 기법
 * - generational collection(세대별 수집):
 * '새로운 객체'와 '오래된 객체'로 나눠 금방 쓸모가 다하는 '새로운 객체'를 '오래된 객체'에 비해 더 많이 감시하는 방법
 *
 * - incremental collection(점진적 수집):
 * 가비지 컬렉션을 여러 부분으로 분리하여 각 부분을 별도로 수행하는 방법
 * 작업 분리, 변경 사항 추적등에 추가 작업이 필요하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다.
 *
 * - idle-time collection(유휴 시간 수집):
 * 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행한다.
 *
 * ...
 */
